# -*- coding: utf-8 -*-
"""Proyecto_Fuga_Empleados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MdbNuNoha1KCyhI1RX6Pl8HJrRpQknEP
"""



"""

```IMPORTANDO DATOS```

# IMPORTANDO DATOS"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
from math import ceil
from datetime import datetime, timedelta

"""## CARGANDO .CSV"""

df = pd.read_csv('AbandonoEmpleados.csv', sep = ';', index_col= 'id', na_values='#N/D')

df

"""# BUSINESS ANALYTICS


"""

df.info()

"""## ANÁLISIS DE NULOS"""

df.isna().sum().sort_values(ascending=False)

"""Conclusiones:

  - Años en puesto y Conciliación: Muchos empleados sin esta variable --> Eliminar esta variable

  sexo                         199
  educacion                    101
  satisfaccion_trabajo          76
  implicacion                   18 --> Imputaremos tras EDA
"""

print(df.columns)

df.drop(columns=['anos_en_puesto', 'conciliacion'], inplace=True)

df.info()

"""## EDA VARIABLES CATEGÓRICAS"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

def eda_categoricas(df):
    """
    Realiza un análisis exploratorio de datos (EDA) para variables categóricas en un DataFrame.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    """
    # Identificar variables categóricas
    cat_columns = df.select_dtypes(include=['object', 'category']).columns

    for col in cat_columns:
        print(f"\nAnálisis de la variable: {col}")

        # Mostrar frecuencias de las categorías
        counts = df[col].value_counts()
        percentages = df[col].value_counts(normalize=True) * 100

        # Mostrar los conteos y porcentajes en la consola
        print(counts)
        print(percentages)

        # Graficar la distribución de las categorías
        plt.figure(figsize=(10, 5))
        ax = sns.countplot(data=df, x=col, order=counts.index)
        plt.title(f'Distribución de la variable {col}')
        plt.xlabel(col)
        plt.ylabel('Frecuencia')
        plt.xticks(rotation=45)

        # Añadir los conteos y porcentajes encima de las barras
        for p in ax.patches:
            height = p.get_height()
            ax.annotate(f'{height}\n({height / len(df) * 100:.1f}%)',
                        (p.get_x() + p.get_width() / 2., height),
                        ha='center', va='bottom')

        plt.show()

# Uso de la función
# df es el DataFrame que contiene tus datos
# eda_categoricas(df)

eda_categoricas(df.select_dtypes('O'))

def graficos_eda_categoricos(cat):
    """
    Realiza un análisis exploratorio de datos (EDA) para variables categóricas en un DataFrame.

    Parámetros:
    cat (pd.DataFrame): DataFrame de pandas que contiene las variables categóricas a analizar.
    """
    # Calculamos el número de filas que necesitamos
    filas = ceil(cat.shape[1] / 2)

    # Definimos el gráfico
    f, ax = plt.subplots(nrows=filas, ncols=2, figsize=(16, filas * 6))

    # Aplanamos para iterar por el gráfico como si fuera de 1 dimensión en lugar de 2
    ax = ax.flat

    # Creamos el bucle que va añadiendo gráficos
    for cada, variable in enumerate(cat):
        counts = cat[variable].value_counts()
        percentages = cat[variable].value_counts(normalize=True) * 100

        sns.barplot(x=counts.values, y=counts.index, ax=ax[cada], palette="viridis")

        for i in ax[cada].patches:
            ax[cada].text(i.get_width() + 0.1, i.get_y() + i.get_height() / 2,
                          f'{int(i.get_width())}\n({i.get_width() / len(cat) * 100:.1f}%)',
                          ha='center', va='center', fontsize=12, color='black', weight='bold')

        ax[cada].set_title(variable, fontsize=12, fontweight="bold")
        ax[cada].tick_params(labelsize = 12)

    # Ajustamos el layout
    plt.tight_layout()
    plt.show()

# Uso de la función
# Seleccionar solo las columnas categóricas del DataFrame
df_categoricas = df.select_dtypes('O')

# Pasar el DataFrame filtrado a la función de EDA
graficos_eda_categoricos(df_categoricas)

"""Conclusiones:

- mayor_edad --> eliminamos
- imputamos educación por Universitaria
- imputamos satisfaccion_trabajo por Alta
- imputamos implicacion por Alta
"""

df.drop(columns = 'mayor_edad', inplace = True)

df['educacion'] = df['educacion'].fillna('Universitaria')

df['satisfaccion_trabajo'] = df['satisfaccion_trabajo'].fillna('Alta')

df['implicacion'] = df['implicacion'].fillna('Alta')

df.info()

def graficos_eda_categoricos(cat):
    """
    Realiza un análisis exploratorio de datos (EDA) para variables categóricas en un DataFrame.

    Parámetros:
    cat (pd.DataFrame): DataFrame de pandas que contiene las variables categóricas a analizar.
    """
    # Calculamos el número de filas que necesitamos
    filas = ceil(cat.shape[1] / 2)

    # Definimos el gráfico
    f, ax = plt.subplots(nrows=filas, ncols=2, figsize=(16, filas * 6))

    # Aplanamos para iterar por el gráfico como si fuera de 1 dimensión en lugar de 2
    ax = ax.flat

    # Creamos el bucle que va añadiendo gráficos
    for cada, variable in enumerate(cat):
        counts = cat[variable].value_counts()
        percentages = cat[variable].value_counts(normalize=True) * 100

        sns.barplot(x=counts.values, y=counts.index, ax=ax[cada], palette="viridis")

        for i in ax[cada].patches:
            ax[cada].text(i.get_width() + 0.1, i.get_y() + i.get_height() / 2,
                          f'{int(i.get_width())}\n({i.get_width() / len(cat) * 100:.1f}%)',
                          ha='center', va='center', fontsize=12, color='black', weight='bold')

        ax[cada].set_title(variable, fontsize=12, fontweight="bold")
        ax[cada].tick_params(labelsize = 12)

    # Ajustamos el layout
    plt.tight_layout()
    plt.show()

# Uso de la función
# Seleccionar solo las columnas categóricas del DataFrame
df_categoricas = df.select_dtypes('O')

# Pasar el DataFrame filtrado a la función de EDA
graficos_eda_categoricos(df_categoricas)

"""## EDA VARIABLES NUMÉRICAS"""

def estadisticos_cont(num):
    #Calculamos describe
    estadisticos = num.describe().T
    #Añadimos la mediana
    estadisticos['median'] = num.median()
    #Reordenamos para que la mediana esté al lado de la media
    estadisticos = estadisticos.iloc[:,[0,1,8,2,3,4,5,6,7]]
    #Lo devolvemos
    return(estadisticos)

estadisticos_cont(df.select_dtypes('number'))

"""Conclusiones:

Empleados solo tiene un valor --> Eliminarla

Sexo tiene 4 valores --> Eliminarla

Horas quincena solo tiene una valor --> Eliminarla

De los nulos pendientes de imputación que sean numéricas solo está el sexo, pero como la vamos a eliminar ya no hay que imputar nada
"""

df.drop(columns = ['empleados','sexo','horas_quincena'], inplace = True)
df

estadisticos_cont(df.select_dtypes('number'))

df

"""## GENERACIÓN DE INSIGHTS

### Cuantificación del problema: ¿Cuál es la tasa de abandono?
"""

df.abandono.value_counts(normalize = True) * 100

"""### ¿Hay un perfil tipo de empleado que deja la empresa?

#### Análisis por Educación
"""

def analizar_abandono_por_educacion(df):
    """
    Analiza la relación entre el nivel de educación y el abandono de la empresa.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    """
    # Crear una tabla cruzada
    crosstab = pd.crosstab(df['educacion'], df['abandono'], normalize='index') * 100
    crosstab.columns = ['No Abandona (%)', 'Abandona (%)']
    print(crosstab)

    # Visualizar la tabla cruzada
    crosstab.plot(kind='bar', stacked=True, figsize=(10, 7), colormap='viridis')
    plt.title('Porcentaje de Abandono por Nivel de Educación')
    plt.xlabel('Nivel de Educación')
    plt.ylabel('Porcentaje')
    plt.legend(loc='best')
    plt.xticks(rotation=45)
    plt.show()

    # Insights
    abandono_max = crosstab['Abandona (%)'].idxmax()
    abandono_min = crosstab['Abandona (%)'].idxmin()

    print(f"\nLos empleados con educación {abandono_max} tienen el mayor porcentaje de abandono: {crosstab.loc[abandono_max, 'Abandona (%)']:.2f}%.")
    print(f"Los empleados con educación {abandono_min} tienen el menor porcentaje de abandono: {crosstab.loc[abandono_min, 'Abandona (%)']:.2f}%.")


# Uso de la función
# df es el DataFrame que contiene tus datos, asegurate de tener las columnas 'educacion' y 'abandono'
analizar_abandono_por_educacion(df)

"""#### Análisis por Edad"""

def analizar_abandono_por_edad(df, bins=10):
    """
    Analiza la relación entre la edad y el abandono de la empresa.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    bins (int): Número de intervalos de edad para agrupar los datos.
    """
    # Crear categorías de edad
    df['grupo_edad'] = pd.cut(df['edad'], bins=bins)

    # Crear una tabla cruzada
    crosstab = pd.crosstab(df['grupo_edad'], df['abandono'], normalize='index') * 100
    crosstab.columns = ['No Abandona (%)', 'Abandona (%)']
    print(crosstab)

    # Visualizar la tabla cruzada
    crosstab.plot(kind='bar', stacked=True, figsize=(10, 7), colormap='viridis')
    plt.title('Porcentaje de Abandono por Grupo de Edad')
    plt.xlabel('Grupo de Edad')
    plt.ylabel('Porcentaje')
    plt.legend(loc='best')
    plt.xticks(rotation=45)
    plt.show()

    # Insights
    abandono_max = crosstab['Abandona (%)'].idxmax()
    abandono_min = crosstab['Abandona (%)'].idxmin()

    print(f"\nLos empleados en el grupo de edad {abandono_max} tienen el mayor porcentaje de abandono: {crosstab.loc[abandono_max, 'Abandona (%)']:.2f}%.")
    print(f"Los empleados en el grupo de edad {abandono_min} tienen el menor porcentaje de abandono: {crosstab.loc[abandono_min, 'Abandona (%)']:.2f}%.")

# Uso de la función
# df es el DataFrame que contiene tus datos, asegúrate de tener las columnas 'edad' y 'abandono'
analizar_abandono_por_edad(df)

"""#### Análisis por Salario Mes"""

def analizar_abandono_por_salario(df, bins=10):
    """
    Analiza la relación entre el salario mensual y el abandono de la empresa.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    bins (int): Número de intervalos de salario para agrupar los datos.
    """
    # Crear categorías de salario
    df['grupo_salario'] = pd.cut(df['salario_mes'], bins=bins)

    # Crear una tabla cruzada
    crosstab = pd.crosstab(df['grupo_salario'], df['abandono'], normalize='index') * 100
    crosstab.columns = ['No Abandona (%)', 'Abandona (%)']
    print(crosstab)

    # Visualizar la tabla cruzada
    crosstab.plot(kind='bar', stacked=True, figsize=(10, 7), colormap='viridis')
    plt.title('Porcentaje de Abandono por Grupo de Salario Mensual')
    plt.xlabel('Grupo de Salario Mensual')
    plt.ylabel('Porcentaje')
    plt.legend(loc='best')
    plt.xticks(rotation=45)
    plt.show()

    # Insights
    abandono_max = crosstab['Abandona (%)'].idxmax()
    abandono_min = crosstab['Abandona (%)'].idxmin()

    print(f"\nLos empleados en el grupo de salario mensual {abandono_max} tienen el mayor porcentaje de abandono: {crosstab.loc[abandono_max, 'Abandona (%)']:.2f}%.")
    print(f"Los empleados en el grupo de salario mensual {abandono_min} tienen el menor porcentaje de abandono: {crosstab.loc[abandono_min, 'Abandona (%)']:.2f}%.")

# Uso de la función
# df es el DataFrame que contiene tus datos, asegurate de tener las columnas 'salario_mes' y 'abandono'
analizar_abandono_por_salario(df)

"""#### Análisis por Satisfaccion Compañeros"""

def analizar_abandono_por_satisfaccion_companeros(df):
    """
    Analiza la relación entre la satisfacción con los compañeros y el abandono de la empresa.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    """
    # Crear una tabla cruzada
    crosstab = pd.crosstab(df['satisfaccion_companeros'], df['abandono'], normalize='index') * 100
    crosstab.columns = ['No Abandona (%)', 'Abandona (%)']
    print(crosstab)

    # Visualizar la tabla cruzada
    crosstab.plot(kind='bar', stacked=True, figsize=(10, 7), colormap='viridis')
    plt.title('Porcentaje de Abandono por Nivel de Satisfacción con los Compañeros')
    plt.xlabel('Nivel de Satisfacción con los Compañeros')
    plt.ylabel('Porcentaje')
    plt.legend(loc='best')
    plt.xticks(rotation=45)
    plt.show()

    # Insights
    abandono_max = crosstab['Abandona (%)'].idxmax()
    abandono_min = crosstab['Abandona (%)'].idxmin()

    print(f"\nLos empleados con satisfacción {abandono_max} tienen el mayor porcentaje de abandono: {crosstab.loc[abandono_max, 'Abandona (%)']:.2f}%.")
    print(f"Los empleados con satisfacción {abandono_min} tienen el menor porcentaje de abandono: {crosstab.loc[abandono_min, 'Abandona (%)']:.2f}%.")

# Uso de la función
# df es el DataFrame que contiene tus datos, asegurate de tener las columnas 'satisfaccion_companeros' y 'abandono'
analizar_abandono_por_satisfaccion_companeros(df)

"""#### Análisis General"""

def analizar_abandono(df, bins=10):
    """
    Analiza la relación entre varias variables y el abandono de la empresa.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    bins (int): Número de intervalos para agrupar las variables numéricas.
    """
    variables_categoricas = ['estado_civil', 'puesto', 'carrera', 'departamento']
    variables_continuas = ['edad', 'salario_mes', 'satisfaccion_companeros', 'satisfaccion_trabajo', 'implicacion']

    # Análisis para variables categóricas
    for var in variables_categoricas:
        print(f"\nAnálisis de abandono por {var}")
        crosstab = pd.crosstab(df[var], df['abandono'], normalize='index') * 100
        crosstab.columns = ['No Abandona (%)', 'Abandona (%)']

        # Ordenar por el porcentaje de abandono
        crosstab = crosstab.sort_values(by='Abandona (%)', ascending=False)

        print(crosstab)

        crosstab.plot(kind='bar', stacked=True, figsize=(10, 7), colormap='viridis')
        plt.title(f'Porcentaje de Abandono por {var.capitalize()}')
        plt.xlabel(var.capitalize())
        plt.ylabel('Porcentaje')
        plt.legend(loc='best')
        plt.xticks(rotation=45)
        plt.show()

        abandono_max = crosstab['Abandona (%)'].idxmax()
        abandono_min = crosstab['Abandona (%)'].idxmin()

        print(f"Los empleados con {var} {abandono_max} tienen el mayor porcentaje de abandono: {crosstab.loc[abandono_max, 'Abandona (%)']:.2f}%.")
        print(f"Los empleados con {var} {abandono_min} tienen el menor porcentaje de abandono: {crosstab.loc[abandono_min, 'Abandona (%)']:.2f}%.")

    # Análisis para variables continuas
    for var in variables_continuas:
        print(f"\nAnálisis de abandono por {var}")
        df[f'grupo_{var}'] = pd.cut(df[var], bins=bins) if df[var].dtype != 'O' else df[var]
        crosstab = pd.crosstab(df[f'grupo_{var}'], df['abandono'], normalize='index') * 100
        crosstab.columns = ['No Abandona (%)', 'Abandona (%)']

        # Ordenar por el porcentaje de abandono
        crosstab = crosstab.sort_values(by='Abandona (%)', ascending=False)

        print(crosstab)

        crosstab.plot(kind='bar', stacked=True, figsize=(10, 7), colormap='viridis')
        plt.title(f'Porcentaje de Abandono por {var.capitalize()}')
        plt.xlabel(var.capitalize())
        plt.ylabel('Porcentaje')
        plt.legend(loc='best')
        plt.xticks(rotation=45)
        plt.show()

        abandono_max = crosstab['Abandona (%)'].idxmax()
        abandono_min = crosstab['Abandona (%)'].idxmin()

        print(f"Los empleados con {var} {abandono_max} tienen el mayor porcentaje de abandono: {crosstab.loc[abandono_max, 'Abandona (%)']:.2f}%.")
        print(f"Los empleados con {var} {abandono_min} tienen el menor porcentaje de abandono: {crosstab.loc[abandono_min, 'Abandona (%)']:.2f}%.")

# Uso de la función
# df es el DataFrame que contiene tus datos, asegurate de tener las columnas necesarias
analizar_abandono(df)

"""#### Análisis de abandono salario y puesto"""

def analizar_salario_por_puesto(df, puestos, bins=10):
    """
    Analiza la relación entre el salario mensual y el abandono de la empresa para puestos específicos.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    puestos (list): Lista de puestos a analizar.
    bins (int): Número de intervalos para agrupar las variables numéricas.
    """
    # Filtrar el DataFrame para los puestos específicos
    df_puestos = df[df['puesto'].isin(puestos)]

    for puesto in puestos:
        df_puesto = df_puestos[df_puestos['puesto'] == puesto]

        print(f"\nAnálisis de salario para el puesto: {puesto}")

        # Crear categorías de salario
        df_puesto['grupo_salario'] = pd.cut(df_puesto['salario_mes'], bins=bins)

        # Crear una tabla cruzada
        crosstab = pd.crosstab(df_puesto['grupo_salario'], df_puesto['abandono'], normalize='index') * 100
        crosstab.columns = ['No Abandona (%)', 'Abandona (%)']

        # Ordenar por el porcentaje de abandono
        crosstab = crosstab.sort_values(by='Abandona (%)', ascending=False)

        print(crosstab)

        # Visualizar la tabla cruzada
        crosstab.plot(kind='bar', stacked=True, figsize=(10, 7), colormap='viridis')
        plt.title(f'Porcentaje de Abandono por Salario Mensual para {puesto}')
        plt.xlabel('Salario Mensual')
        plt.ylabel('Porcentaje')
        plt.legend(loc='best')
        plt.xticks(rotation=45)
        plt.show()

        # Insights
        abandono_max = crosstab['Abandona (%)'].idxmax()
        abandono_min = crosstab['Abandona (%)'].idxmin()

        print(f"Los empleados en el grupo de salario {abandono_max} en {puesto} tienen el mayor porcentaje de abandono: {crosstab.loc[abandono_max, 'Abandona (%)']:.2f}%.")
        print(f"Los empleados en el grupo de salario {abandono_min} en {puesto} tienen el menor porcentaje de abandono: {crosstab.loc[abandono_min, 'Abandona (%)']:.2f}%.")

# Uso de la función
# df es el DataFrame que contiene tus datos, asegúrate de tener las columnas necesarias
puestos_a_analizar = ['Sales Representative', 'Human Resources']
analizar_salario_por_puesto(df, puestos_a_analizar)

"""#### Análisis de los puestos con menor salario"""

def analizar_salarios_por_puesto(df):
    """
    Analiza y visualiza los salarios promedio por puesto en la empresa.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    """
    # Calcular el salario promedio por puesto
    salario_promedio_por_puesto = df.groupby('puesto')['salario_mes'].mean().sort_values()

    print(salario_promedio_por_puesto)

    # Visualizar los salarios promedio por puesto
    plt.figure(figsize=(10, 7))
    salario_promedio_por_puesto.plot(kind='barh', colormap='viridis')
    plt.title('Salario Promedio por Puesto')
    plt.xlabel('Salario Promedio (mensual)')
    plt.ylabel('Puesto')
    plt.show()

    # Puestos con los salarios más bajos
    puestos_menor_salario = salario_promedio_por_puesto.head(5)
    print("\nPuestos con los salarios más bajos:")
    print(puestos_menor_salario)

# Uso de la función
# df es el DataFrame que contiene tus datos, asegúrate de tener las columnas 'salario_mes' y 'puesto'
analizar_salarios_por_puesto(df)

"""#### Análisis de Edad por Puesto"""

def analizar_edad_por_puesto(df):
    """
    Analiza la relación entre los puestos y la edad de los empleados.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    """
    plt.figure(figsize=(15, 10))
    sns.boxplot(x='puesto', y='edad', data=df, palette='viridis')
    plt.title('Distribución de Edad por Puesto')
    plt.xlabel('Puesto')
    plt.ylabel('Edad')
    plt.xticks(rotation=90)
    plt.show()

    # Mostrar estadísticas descriptivas de edad por puesto
    stats_por_puesto = df.groupby('puesto')['edad'].describe()
    print(stats_por_puesto)

# Uso de la función
# df es el DataFrame que contiene tus datos, asegúrate de tener las columnas 'edad' y 'puesto'
analizar_edad_por_puesto(df)

"""#### Análisis de Carrera por Puesto"""

def analizar_carrera_por_puesto(df):
    """
    Analiza la relación entre los puestos y las carreras de los empleados.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    """
    # Crear una tabla cruzada
    crosstab = pd.crosstab(df['puesto'], df['carrera'], normalize='index') * 100

    # Visualizar la tabla cruzada con un gráfico de barras apiladas
    crosstab.plot(kind='bar', stacked=True, figsize=(15, 10), colormap='viridis')
    plt.title('Distribución de Carreras por Puesto')
    plt.xlabel('Puesto')
    plt.ylabel('Porcentaje')
    plt.legend(title='Carrera', bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.xticks(rotation=90)
    plt.show()

    # Mostrar estadísticas descriptivas de carrera por puesto
    stats_por_puesto = df.groupby('puesto')['carrera'].value_counts(normalize=True).unstack().fillna(0) * 100
    print(stats_por_puesto)

# Uso de la función
# df es el DataFrame que contiene tus datos, asegúrate de tener las columnas 'carrera' y 'puesto'
analizar_carrera_por_puesto(df)

"""#### Análisis de Nivel de Estudios por Puesto"""

def analizar_nivel_estudios_por_puesto(df):
    """
    Analiza la relación entre los puestos y los niveles de estudios de los empleados.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    """
    # Crear una tabla cruzada
    crosstab = pd.crosstab(df['puesto'], df['educacion'], normalize='index') * 100

    # Visualizar la tabla cruzada con un gráfico de barras apiladas
    crosstab.plot(kind='bar', stacked=True, figsize=(15, 10), colormap='viridis')
    plt.title('Distribución de Nivel de Estudios por Puesto')
    plt.xlabel('Puesto')
    plt.ylabel('Porcentaje')
    plt.legend(title='Nivel de Estudios', bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.xticks(rotation=90)
    plt.show()

    # Mostrar estadísticas descriptivas de nivel de estudios por puesto
    stats_por_puesto = df.groupby('puesto')['educacion'].value_counts(normalize=True).unstack().fillna(0) * 100
    print(stats_por_puesto)

# Uso de la función
# df es el DataFrame que contiene tus datos, asegúrate de tener las columnas 'educacion' y 'puesto'
analizar_nivel_estudios_por_puesto(df)

"""#### Análisis de Satisfacción del Trabajo por Puesto"""

def analizar_satisfaccion_trabajo_por_puesto(df):
    """
    Analiza la relación entre los puestos y la satisfacción en el trabajo de los empleados.

    Parámetros:
    df (pd.DataFrame): DataFrame de pandas que contiene las variables a analizar.
    """
    # Crear una tabla cruzada
    crosstab = pd.crosstab(df['puesto'], df['satisfaccion_trabajo'], normalize='index') * 100

    # Visualizar la tabla cruzada con un gráfico de barras apiladas
    crosstab.plot(kind='bar', stacked=True, figsize=(15, 10), colormap='viridis')
    plt.title('Distribución de Satisfacción en el Trabajo por Puesto')
    plt.xlabel('Puesto')
    plt.ylabel('Porcentaje')
    plt.legend(title='Satisfacción en el Trabajo', bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.xticks(rotation=90)
    plt.show()

    # Mostrar estadísticas descriptivas de satisfacción en el trabajo por puesto
    stats_por_puesto = df.groupby('puesto')['satisfaccion_trabajo'].value_counts(normalize=True).unstack().fillna(0) * 100
    print(stats_por_puesto)

# Uso de la función
# df es el DataFrame que contiene tus datos, asegúrate de tener las columnas 'satisfaccion_trabajo' y 'puesto'
analizar_satisfaccion_trabajo_por_puesto(df)

"""#### Conclusiones

Resumen General

Perfiles de Alto Abandono:

Educación: Empleados con niveles educativos más bajos --> **Primaria**

Edad: Empleados más jóvenes, posiblemente buscando avances rápidos --> **Rango de edad, de los 18 a los 26 años**

Salario: Empleados en los rangos de salario más bajos                        
**(990.01, 2908.0]**

Satisfacción: Empleados con baja satisfacción en el trabajo y con los compañeros --> Baja

Puestos Específicos: **Sales Representative** seguido de **Human Resources**

#### IMPACTO ECONÓMICO de este problema

Según el estudio "Cost of Turnover" del Center for American Progress:

* El coste de la fuga de los empleados que ganan menos de 30000 es del 16,1% de su salario

* El coste de la fuga de los empleados que ganan entre 30000-50000 es del 19,7% de su salario

* El coste de la fuga de los empleados que ganan entre 50000-75000 es del 20,4% de su salario

* El coste de la fuga de los empleados que ganan más de 75000 es del 21% de su salario
"""

# Creamos una nueva variable salario_ano del empleado
df['salario_ano'] = df.salario_mes.transform(lambda x: x*12)
df[['salario_mes','salario_ano']]

# Calculamos el impacto económico de cada empleado si deja la empresa

#Lista de condiciones
condiciones = [(df['salario_ano'] <= 30000),
               (df['salario_ano'] > 30000) & (df['salario_ano'] <= 50000),
               (df['salario_ano'] > 50000) & (df['salario_ano'] <= 75000),
               (df['salario_ano'] > 75000)]

#Lista de resultados
resultados = [df.salario_ano * 0.161, df.salario_ano * 0.197, df.salario_ano * 0.204, df.salario_ano * 0.21]

#Aplicamos select
df['impacto_abandono'] = np.select(condiciones,resultados, default = -999)

df

"""#### ¿Cuánto nos ha costado este problema en el último año?"""

# Convertir los valores 'Yes' y 'No' a 1 y 0 respectivamente
df['abandono'] = df['abandono'].replace({'Yes': 1, 'No': 0})

# Crear la columna 'salario_ano'
df['salario_ano'] = df['salario_mes'] * 12

# Lista de condiciones para calcular el impacto económico
condiciones = [
    (df['salario_ano'] <= 30000),
    (df['salario_ano'] > 30000) & (df['salario_ano'] <= 50000),
    (df['salario_ano'] > 50000) & (df['salario_ano'] <= 75000),
    (df['salario_ano'] > 75000)
]

# Lista de resultados basados en los porcentajes del estudio
resultados = [
    df['salario_ano'] * 0.161,
    df['salario_ano'] * 0.197,
    df['salario_ano'] * 0.204,
    df['salario_ano'] * 0.21
]

# Crear la columna 'impacto_abandono'
df['impacto_abandono'] = np.select(condiciones, resultados, default=0)

# Verificar la creación de las columnas
print("Datos con salario anual e impacto de abandono:")
print(df[['salario_mes', 'salario_ano', 'abandono', 'impacto_abandono']])

# Filtrar los empleados que han abandonado
df_abandono = df[df['abandono'] == 1]

# Verificar los empleados que han abandonado
print("Empleados que han abandonado:")
print(df_abandono[['salario_ano', 'impacto_abandono']])

# Calcular el coste total del abandono
coste_total = df_abandono['impacto_abandono'].sum()
print(f"Coste total del abandono de empleados: ${coste_total:,.2f}")

"""#### ¿Cuanto nos cuesta que los empleados no estén motivados? (pérdidas en implicación == Baja)"""

df.loc[(df.abandono == 1) & (df.implicacion == 'Baja')].impacto_abandono.sum()

"""#### ¿Cuánto dinero podríamos ahorrar fidelizando mejor a nuestros empleados?"""

print(f"Reducir un 10% la fuga de empleados nos ahorraría {int(coste_total * 0.1)}$ cada año.")

print(f"Reducir un 20% la fuga de empleados nos ahorraría {int(coste_total * 0.2)}$ cada año.")

print(f"Reducir un 30% la fuga de empleados nos ahorraría {int(coste_total * 0.3)}$ cada año.")

from google.colab import drive
drive.mount('/content/drive')

"""# MODELO DE MACHINE LEARNING"""

df_ml = df.copy()

df_ml.info()

"""## PREPARACIÓN DE LOS DATOS PARA LA MODELIZACIÓN

### Transformar todas las variables categóricas a numéricas
"""

from sklearn.preprocessing import OneHotEncoder

#Categóricas
cat = df_ml.select_dtypes('O')

#Instanciamos
ohe = OneHotEncoder(sparse = False)

#Entrenamos
ohe.fit(cat)

#Aplicamos
cat_ohe = ohe.transform(cat)

#Ponemos los nombres
cat_ohe = pd.DataFrame(cat_ohe, columns = ohe.get_feature_names_out(input_features = cat.columns)).reset_index(drop = True)

cat_ohe

"""### Datraframe Final"""

num = df.select_dtypes('number').reset_index(drop = True)

df_ml = pd.concat([cat_ohe,num], axis = 1)
df_ml

"""## DISEÑO DE LA MODELIZACIÓN

### Separación predictoras y target
"""

x = df_ml.drop(columns='abandono')
y = df_ml['abandono']

"""### Separación train y test"""

from sklearn.model_selection import train_test_split

train_x, test_x, train_y, test_y = train_test_split(x, y, test_size = 0.3)

"""## ENTRENAMIENTO DEL MODELO SOBRE TRAIN"""

from sklearn.tree import DecisionTreeClassifier

#Instanciar
ac = DecisionTreeClassifier(max_depth=4)

#Entrenar
ac.fit(train_x,train_y)

"""## PREDICCIÓN Y VALIDACIÓN SOBRE TEST"""

# Predicción
pred = ac.predict_proba(test_x)[:, 1]
pred[:50]

# Evaluación
from sklearn.metrics import roc_auc_score

roc_auc_score(test_y,pred)

"""## INTERPRETACIÓN

### Diagrama del árbol
"""

from sklearn.tree import plot_tree

plt.figure(figsize = (50,50))

plot_tree(ac,
          feature_names= test_x.columns,
          impurity = False,
          node_ids = True,
          proportion = True,
          rounded = True,
          precision = 2);

"""### Importancia de las variables"""

pd.Series(ac.feature_importances_,index = test_x.columns).sort_values(ascending = False).plot(kind = 'bar', figsize = (30,20));

"""## EXPLOTACIÓN"""

df['scoring_abandono'] = ac.predict_proba(df_ml.drop(columns = 'abandono'))[:, 1]
df

"""Ejemplo de los 10 empleados con mayor probabilidad de abandonar la empresa"""

df.sort_values(by = 'scoring_abandono', ascending = False)[0:10]

"""Ejemplo: riesgo de dejar la empresa por puesto de trabajo"""

df.boxplot(column='scoring_abandono', by='puesto', figsize = (20,12));

"""## GUARDAR EL RESULTADO"""

df

from google.colab import files

df.to_excel('abandono_con_scoring.xlsx')
files.download('abandono_con_scoring.xlsx')

